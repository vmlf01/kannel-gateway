<chapter>
<title>Internal structure: hosts, modules, threads</title>

	<para>This chapter describes the major internal components
	of the gateway and their interaction in general terms.</para>

	<figure>
	<title>Major gateway components</title>
	<graphic fileref="arch-components&figtype;"></graphic>
	</figure>
	
	<para>The gateway will divide the processing load on several
	hosts, which are of three different types:
	
	<variablelist>
	<varlistentry>
		<term>Bearer box
		</term>
		<listitem>
		<para>This host connects to the SMS centers and CSD
		routers, and provides a unified interface to them for
		the other boxes. It implements the WDP layer of the
		WAP stack.  </para>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>WAP box
		</term>
		<listitem>
		<para>These hosts run the upper layers of the WAP stack.
		Each session and the transactions that belong to that
		session are handled by the same WAP box. Sessions and
		transactions are not migrated between WAP boxes.
		</para>
		</listitem>
	</varlistentry>
	<varlistentry>
		<term>SMS box
		</term>
		<listitem>
		<para>These hosts run the SMS gateway. They can't connect
		directly to the SMS centers, because the same SMS center
		connection can be used for both SMS services and WAP.
		</para>
		</listitem>
	</varlistentry>
	</variablelist>
	
	There can, in this design, only be one bearer box, but any number
	of the other boxes. (This is a potential performance bottleneck,
	and will be dealt with later.)</para>

	<para>The bearer box receives SMS messages from SMS
	centers, inspects them to see whether they are plain
	SMS messages or contain WAP packets, and then routes
	them to the appropriate kind of box. It keeps track
	of the WAP and SMS boxes that are currently running,
	and routes all messages from a particular terminal to
	the same box. Similarly, it receives UDP packets from
	CSD routers and routes them to the boxes based on the
	sender. This simple design allows the bearer box to
	do as little processing as possible per packet, which
	reduces its bottleneck karma. </para>
	
	<para>The bearer box also sends the SMS messages and
	UDP packets that the other boxes generate. This adds
	some more routing processing.</para>
	
	<para>The WAP boxes implement the WTP (transaction) and
	WSP (session) layers (and the WTSL security layer in the
	future). These take HTTP-like requests from the phones, and
	make the actual HTTP requests to content servers, compress
	the response, and send it back to the terminals. (Sessions are
	needed to make as much use of the limited radio bandwidth as
	possible.) Each transaction and session is represented by a
	data structure that implements (together with the static state
	machine engine code) the state machine for that layer. Each new
	WDP packet is handled by a new thread in a WAP box. That thread
	finds the correct WTP state machine or creates a new one. It then
	feeds the WDP packet as an event to the WTP state machine. If
	that state machine needs to deal with a session, it calls the WSP
	engine code to find or create a WSP state machine, and feeds the
	suitable events to that state machine. This is all handled by the
	same thread that was originally created to handle the WDP packet.
	And similarly, if the WSP state machine needs to give events
	to a WTP state machine, it is handled by the same thread. Once
	all the events that are spawned by the WDP packet are handled,
	the thread dies.</para>
	
<!--	XXX is a WTP transaction involved when a new session is opened? -->

	<para>It is possible that bursts of WDP packets arrive faster
	than they can be processed. In that case, normal locking of data
	structures ensures that only one packet at a time is handled,
	and the rest are queued. In fact, if the newly created thread for
	a new WDP packet notices it can't process the packet, because the
	corresponding WTP state machine is still locked by the previous
	packet, it will put the event in a WTP state machine specific
	queue and terminate. The thread that has the lock will, after
	it has processed its packet (or other event), look at the state
	machine's pending event queue and process the packets there. This
	way, there need not be unnecessary threads. This is important
	when there is lots of traffic due to lots of users: it is important
	that the thread table of the operating system is not filled.</para>
	
	<para>The SMS boxes implement traditional SMS services: SMS messages
	with keywords and arguments are translated into URLs and the
	corresponding HTML pages are stripped of markup and sent to the
	phone.</para>
	
</chapter>
