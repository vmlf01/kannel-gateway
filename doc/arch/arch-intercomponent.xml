<chapter>
<title>Inter-component communication</title>

	<para>This chapter describes the communication between components
	of the gateway.</para>
	
	<para>The connection between the bearer box and a WAP or
	SMS box is a TCP stream connection. The bearer box acts as
	a server and waits for the the WAP and SMS boxes to connect
	to the bearer box. This way, the bearer box does not have to
	have a static list of the other boxes. Instead, it starts with
	an empty list and waits for the others to register themselves.
	This design makes it trivial to add new WAP and SMS boxes:
	you just install a new one and configure it to connect to the
	appropriate bearer box.</para>
	
	<para>If the TCP stream between the bearer box and a WAP or SMS
	box breaks, the bearer box will notice this and remove that box
	from its list of clients. This makes for a simple fault tolerance
	design. Once the crashed box has been removed from the list of
	clients, packet from phones that were routed to that box will be
	treated as packets from new clients. This means that the WAP boxes
	need to be able to handle packets from the middle of a session and
	treat them as errors (silent, or preferably by responding with
	error messages to the phone).</para>
	
	<para>In addition to messages related to protocol packets received
	from or sent outside the gateway, the boxes within the gateway
	send <glossterm>heartbeat</glossterm> packets. These are used to
	keep track of which boxes are alive and which are not functional.
	Each box sends a message at regular intervals to the bearer box
	that says, essentially, <quote>I'm alive and well</quote>. If the
	bearer box does not receive such messages, it will assume that
	the other box in question has crashed, but not enough to make
	the TCP stream break. It then closes the stream and removes the
	box from its list of contents. When the other box is well again,
	it will re-open the connection.</para>
	
	<para>The heartbeat message includes the sender's load. The
	bearer box will use this for load balancing.</para>
	
<sect1>
<title>General message structure and implementation</title>

	<para>For communication between gateway components, we will use
	the same general message structure and implementation. This will
	make it easier to get things to work corretly and will make it
	easier to modify messages by minimizing the need to write tedious,
	repetitious, monotonous, error-prone code. The way we will do
	this is, however, a hack that needs to be explained.</para>
	
	<para>Messages always begin with a length (integers, see below)
	and a type field (integer).  The other fields are either
	integers (signed 32 bits, network byte order) or variable length
	strings (integer giving length, then that many octets). There
	can be any number of fields, and they can come in any order
	(except that the type is always first).</para>
	
	<para>In main memory, messages are represented by the
	<structname>Msg</structname> structure. This structure contains
	the field <structfield>type</structfield>, which gives its type, and
	a separate struct field for each type of message, named after
	the type. The fields in the message are fields in the message
	type specific structrue. For example, the hearbeat message contains
	one field giving the load of the sender, and this would be
	accessed like this:

<programlisting>msg->heartbeat.load</programlisting>

	</para>
	
	<para>The file <filename>msg.h</filename> defines the following
	functions for manipulating <structname>Msg</structname> structures:
	
	<variablelist>

	<varlistentry>
		<term><function>msg_create</function></term>
		<listitem>
			<para>Creates an empty <structname>Msg</structname>
			structure. The caller should fill in the
			message type specific fields manually.
			</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term><function>msg_destroy</function></term>
		<listitem>
			<para>Destroys a <structname>Msg</structname>
			structure, including all fields.
			</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term><function>msg_pack</function></term>
		<listitem>
			<para>Creates an <structname>Octstr</structname>
			from the fields of a <structname>Msg</structname>.
			The <structname>Octstr</structname> can easily
			be sent via the TCP stream to the receiving box.
			</para>
		</listitem>
	</varlistentry>

	<varlistentry>
		<term><function>msg_unpack</function></term>
		<listitem>
			<para>Unpacks an <structname>Octstr</structname>
			into a <structname>Msg</structname>. The
			<structname>Octstr</structname> can easily be
			read from a TCP stream.
			</para>
		</listitem>
	</varlistentry>

	</variablelist>
	
	<filename>msg.h</filename> also declares the
	<structname>Msg</structname> type.  </para>
	
	<para>The names and contents of messages are declared in the
	file <filename>msg-decl.h</filename>. This file obeys a special
	syntax so that the functions in <filename>msg.h</filename>
	can be implemented automatically. The code to, say, initialize
	each field in <structname>Msg</structname> is not written by
	hand.  Instead, C preprocessor magic is employed to expand the
	declaration of the message to code that initializes the fields.
	It is not necessary to understand how the expansion is done
	to know how to use the functions or define new message types
	(and the magic isn't explained here).  </para>
	
	<para>Each message is defined using the <function>MSG</function>
	command (implemented as a macro):
	
<programlisting>MSG(sms,
    {
        OCTSTR(sender);
        OCTSTR(receiver);
        INTEGER(has_udh);
        OCTSTR(text);
    })</programlisting>
    	</para>
    
	<para>Here, <structfield>sms</structfield> is the type of
	the message. Each type is given a symbolic name that is a valid
	C identifier. The name is used everywhere in the code to refer
	to the message type.</para>
	
	<para>The fields of the message are declared as the second
	<function>MSG</function> argument. The second argument must be
	a C statement that calls <function>OCTSTR</function> and
	<function>INTEGER</function> for each field (depending on its
	type, of course) to define its type. C preprocessor magic turns
	the statements into code that, for example, destroy each field
	in the message.</para>
	
	<formalpara>
	<title>Acknowledgement</title>
	<para>This implementation idea for messages is from Kenneth
	Oksanen and the HiBase project at the Helsinki University of
	Technology.</para>
	</formalpara>

	
</sect1>

<sect1>
<title>Heartbeat messages</title>

	<para>Both the SMS and WAP boxes send heartbeat messages to the
	bearer box. The hearbeat informs the bearer box that the sender
	is alive and also its load. The message is simple:
	
	<simplelist>
	<member>Load (integer)</member>
	</simplelist>
	
	The load indicates the number of HTTP requests that the sending
	box has open at the time of sending the heartbeat message.</para>
	
</sect1>

<sect1>
<title>SMS messages between bearer and SMS boxes</title>

	<para>The bearer box sends SMS messages to the SMS boxes and
	these reply with new SMS messages. SMS messages consist of
	the following pieces of information:
	
	<simplelist>
	<member>Sender phone number (string)</member>
	<member>Receiver phone number (string)</member>
	<member>Contents of message (string)</member>
	</simplelist>
	
	Phone numbers are normalized, meaning that whatever part of the
	gateway accepts a phone number from the world outside the gateway,
	it will make sure it is normalized to a global format. The bearer
	box will know from a normalized phone number via which SMS center
	it should be routed.  </para>
	
	<para>SMS messages can contain so called User Data Headers.
	Whether they do is indicated in the message type.</para>
	
</sect1>

<sect1>
<title>WDP messages between bearer and WAP boxes</title>

	<para>The bearer box sends WDP messages to the WAP boxes and
	these reply with new WDP messages. WDP messages consist of
	the following pieces of information:
	
	<simplelist>
	<member>Source address (string)</member>
	<member>Source port (integer)</member>
	<member>Destination address (string)</member>
	<member>Destination port (integer)</member>
	<member>The data in the message (string)</member>
	</simplelist>
	
	Addresses can be in any number of different formats (IP numbers,
	phone numbers, with more to come). The address may need to
	contain a prefix that specifies the type. The WAP box doesn't
	need to worry about the address, except for using it to identify
	the WTP and WSM state machine it needs to use; it just treats it
	as a black box and puts it in the proper place in the response
	message.  </para>
	
</sect1>

</chapter>
