/*
 * smsbox_req.c - fulfill sms requests from users
 *
 * This module handles the request handling - that is, finding
 * the correct urltranslation, fetching the result, then
 * splitting it into several messages if necessary, and sending
 * the messages to the phone.
 */

#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <string.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "gwlib/gwlib.h"
#include "html.h"
#include "msg.h"

#include "smsbox.h"
#include "smsbox_req.h"
#include "urltrans.h"

#ifdef HAVE_SECURITY_PAM_APPL_H
#include <security/pam_appl.h>
#endif


/* Defines */

#define	CONN_TEMP	0x60
#define	CONN_CONT	0x61
#define	CONN_SECTEMP	0x62
#define	CONN_SECCONT	0x63
#define AUTH_NORMAL	0x70
#define AUTH_SECURE	0x71
#define BEARER_DATA	0x45
#define CALL_ISDN	0x73
#define SPEED_9660	"6B"
#define SPEED_14400	"6C"
#define ENDTAG		"01"

/* Global variables */

static URLTranslationList *translations = NULL;
static int sms_max_length = -1;		/* not initialized - never modify
                                         * after smsbox_req_init! */
static char *sendsms_number_chars;
static char *global_sender = NULL;
static Config 	*cfg = NULL;

#define SENDSMS_DEFAULT_CHARS "0123456789 +-"


List *smsbox_requests = NULL;


/***********************************************************************
 * SMS splitting.
 */


/*
 * Number of octets in the catenation UDH part.
 */
enum { CATENATE_UDH_LEN = 5 };


/*
 * Counter for catenated SMS messages. The counter that can be put into
 * the catenated SMS message's UDH headers is actually the lowest 8 bits.
 */
static Counter *catenated_sms_counter;


static void prepend_catenation_udh(Msg *sms, int part_no, int num_messages,
    	    	    	    	   int msg_sequence)
{
    gw_assert(sms->sms.udhdata != NULL);
    octstr_format_append(sms->sms.udhdata, "\0\3%c%c%c", 
    	    	    	 part_no, num_messages, msg_sequence);
    sms->sms.flag_udh = 1;
}


static Octstr *extract_msgdata_part(Octstr *msgdata, Octstr *split_chars,
    	    	    	    	    int max_part_len)
{
    long i, j, len;
    Octstr *part;

    len = -1;
    for (i = 0; i < octstr_len(split_chars); ++i) {
	j = octstr_search_char(msgdata, octstr_get_char(split_chars, i), 0);
	if (len < j && j <= max_part_len)
	    len = j;
    }
    if (len == -1)
    	len = max_part_len;
	
    part = octstr_copy(msgdata, 0, len);
    octstr_delete(msgdata, 0, len);
    return part;
}


/*
 * 
 * Split an SMS message into smaller ones.
 * 
 * The original SMS message is represented as an Msg object, and the
 * resulting list of smaller ones is represented as a List of Msg objects.
 * A plain text header and/or footer can be added to each part, and an
 * additional suffix can be added to each part except the last one.
 * Optionally, a UDH prefix can be added to each part so that phones
 * that understand this prefix can join the messages into one large one
 * again. At most `max_messages' parts will be generated; surplus text
 * from the original message will be silently ignored.
 * 
 * If the original message has UDH, they will be duplicated in each part.
 * It is an error to use catenation and UDH together, or catenation and 7
 * bit mode toghether; in these cases, catenation is silently ignored.
 * 
 * If `catenate' is true, it is used as the sequence number for the logical
 * message. The catenation UDH contain three numbers: the sequence number
 * of the part in the logical (unsplit) message, the total number of parts
 * in the logical message, and the sequence number of the logical message
 * itself, in case we're sending several large logical messages to the
 * same recipient. The first two can be generated by sms_split itself,
 * and `catenate' is used as the third one.
 *
 * Note that `catenate' must have a value in the range 0..255.
 * 
 * `max_octets' gives the maximum number of octets in on message, including
 * UDH, and after 7 bit characters have been packed into octets.
 */
static List *sms_split(Msg *orig, Octstr *header, Octstr *footer, 
		       Octstr *nonlast_suffix, Octstr *split_chars, 
		       int catenate, int max_messages, int max_octets)
{
    long max_part_len;
    long i, num_messages;
    List *list;
    Msg *part;
    Octstr *msgdata;

    /* Forget about catenation, if `orig' has UDH. */
    if (catenate && (orig->sms.flag_udh || !orig->sms.flag_8bit))
    	catenate = 0;

    /* Compute maximum number of unpacked octets in each part. */
    if (orig->sms.flag_8bit)
    	max_part_len = max_octets;
    else
    	max_part_len = (max_octets * 8) / 7;
    max_part_len -= octstr_len(header) + octstr_len(footer);
    if (orig->sms.flag_udh)
    	max_part_len -= octstr_len(orig->sms.udhdata);
    if (catenate)
        max_part_len -= CATENATE_UDH_LEN;

    /* Compute the number of output messages. */
    num_messages = roundup_div(octstr_len(orig->sms.msgdata), max_part_len);
    if (num_messages > max_messages)
    	num_messages = max_messages;

    /* Do the actual splitting. */
    list = list_create();
    msgdata = octstr_duplicate(orig->sms.msgdata);
    for (i = 0; i < num_messages; ++i) {
	part = msg_duplicate(orig);
	octstr_destroy(part->sms.msgdata);
	part->sms.msgdata = extract_msgdata_part(msgdata, split_chars,
	    	    	    	    	    	 max_part_len);
	if (header)
	    octstr_insert(part->sms.msgdata, header, 0);
	if (footer)
	    octstr_append(part->sms.msgdata, footer);
	if (i+1 < num_messages && nonlast_suffix)
	    octstr_append(part->sms.msgdata, nonlast_suffix);
	
	if (catenate)
	    prepend_catenation_udh(part, i+1, num_messages, catenate);
	
	list_append(list, part);
    }
    
    return list;
}


/*-------------------------------------------------------------------*
 * STATIC FUNCTIONS
 */

static int send_message(URLTranslation *trans, Msg *msg);

static HTTPCaller *caller;
static Dict *receivers;

struct receiver {
    Msg *msg;
    URLTranslation *trans;
};

static void destroy_receiver(void *p)
{
    struct receiver *r;
    
    r = p;
    msg_destroy(r->msg);
    gw_free(r);
}

static void remember_receiver(long id, Msg *msg, URLTranslation *trans)
{
    Octstr *idstr;
    struct receiver *receiver;
    
    receiver = gw_malloc(sizeof(*receiver));

    receiver->msg = msg_create(sms);
    receiver->msg->sms.sender = octstr_duplicate(msg->sms.sender);
    receiver->msg->sms.receiver = octstr_duplicate(msg->sms.receiver);
    receiver->msg->sms.flag_8bit = 0;
    receiver->msg->sms.flag_udh = 0;
    receiver->msg->sms.udhdata = NULL;
    receiver->msg->sms.msgdata = NULL;
    receiver->msg->sms.time = (time_t) -1;
    receiver->msg->sms.smsc_id = octstr_duplicate(msg->sms.smsc_id);
    
    receiver->trans = trans;

    idstr = octstr_format("%ld", id);
    dict_put(receivers, idstr, receiver);
    octstr_destroy(idstr);
}


static void get_receiver(long id, Msg **msg, URLTranslation **trans)
{
    Octstr *idstr;
    struct receiver *receiver;
    
    idstr = octstr_format("%ld", id);
    receiver = dict_remove(receivers, idstr);
    octstr_destroy(idstr);
    *msg = receiver->msg;
    *trans = receiver->trans;
    gw_free(receiver);
}


static void strip_prefix_and_suffix(Octstr *html, char *prefix, char *suffix)
{
    char *p, *q, *data;

    if (prefix == NULL || suffix == NULL)
    	return;
    data = octstr_get_cstr(html);
    p = str_case_str(data, prefix);
    if (p == NULL)
        return;
    p += strlen(prefix);
    q = str_case_str(p, suffix);
    if (q == NULL)
        return;
    octstr_delete(html, 0, p - data);
    octstr_truncate(html, q - p);
}



static void url_result_thread(void *arg)
{
    Octstr *final_url, *reply_body, *type, *charset, *replytext;
    List *reply_headers;
    int status;
    long id;
    Msg *msg;
    URLTranslation *trans;
    Octstr *text_html;
    Octstr *text_plain;
    Octstr *text_wml;

    text_html = octstr_create_immutable("text/html");
    text_wml = octstr_create_immutable("text/vnd.wap.wml");
    text_plain = octstr_create_immutable("text/plain");

    for (;;) {
    	id = http_receive_result(caller, &status, &final_url, &reply_headers,
	    	    	    	 &reply_body);
    	if (id == -1)
	    break;
    	
    	get_receiver(id, &msg, &trans);

    	if (status == HTTP_OK) {
	    http_header_get_content_type(reply_headers, &type, &charset);
	    if (octstr_compare(type, text_html) == 0 ||
		octstr_compare(type, text_wml) == 0) {
		strip_prefix_and_suffix(reply_body,
					urltrans_prefix(trans), 
					urltrans_suffix(trans));
		replytext = html_to_sms(reply_body);
	    } else if (octstr_compare(type, text_plain) == 0) {
		replytext = reply_body;
		reply_body = NULL;
	    } else {
		replytext = octstr_create("Result could not be represented "
					  "as an SMS message.");
	    }
	    octstr_destroy(type);
	    octstr_destroy(charset);
	} else
	    replytext = octstr_create("Could not fetch content, sorry.");
    
	octstr_strip_blanks(replytext);
	msg->sms.msgdata = replytext;
	msg->sms.time = time(NULL);
    
    	if (final_url == NULL)
	    final_url = octstr_create_immutable("");
    	if (reply_body == NULL)
	    reply_body = octstr_create_immutable("");
	alog("SMS HTTP-request sender:%s request: '%s' "
	     "url: '%s' reply: %d '%s'",
	     octstr_get_cstr(msg->sms.receiver),
	     octstr_get_cstr(msg->sms.msgdata),
	     octstr_get_cstr(final_url),
	     status,
	     (status == HTTP_OK) 
		? "<< successful >>"
		: octstr_get_cstr(reply_body));
		
    	octstr_destroy(final_url);
	http_destroy_headers(reply_headers);
	octstr_destroy(reply_body);
    
	if (send_message(trans, msg) < 0)
	    error(0, "failed to send message to phone");
    }
}


/*
 * Perform the service requested by the user: translate the request into
 * a pattern, if it is an URL, start its fetch and return 0, otherwise
 * return the string in `*result' and return 1. Return -1 for errors,
 */
static int obey_request(Octstr **result, URLTranslation *trans, Msg *msg)
{
    char *pattern;
    Octstr *url;
    List *request_headers;
    long id;
    
    gw_assert(msg != NULL);
    gw_assert(msg_type(msg) == sms);
    
    pattern = urltrans_get_pattern(trans, msg);
    gw_assert(pattern != NULL);
    
    switch (urltrans_type(trans)) {
    case TRANSTYPE_TEXT:
	debug("sms", 0, "formatted text answer: <%s>", pattern);
	*result = octstr_create(pattern);
	alog("SMS request sender:%s request: '%s' fixed answer: '%s'",
	     octstr_get_cstr(msg->sms.receiver),
	     octstr_get_cstr(msg->sms.msgdata),
	     pattern);
	break;
    
    case TRANSTYPE_FILE:
	*result = octstr_read_file(pattern);
	gw_free(pattern);
	alog("SMS request sender:%s request: '%s' file answer: '%s'",
	     octstr_get_cstr(msg->sms.receiver),
	     octstr_get_cstr(msg->sms.msgdata),
	     octstr_get_cstr(*result));
	break;
    
    case TRANSTYPE_URL:
	url = octstr_create(pattern);
	gw_free(pattern);
	request_headers = list_create();
	id = http_start_request(caller, url, request_headers, NULL, 1);
	octstr_destroy(url);
	http_destroy_headers(request_headers);
	if (id == -1)
	    goto error;
	remember_receiver(id, msg, trans);
	*result = NULL;
	return 0;
    
    default:
	error(0, "Unknown URL translation type %d", urltrans_type(trans));
	alog("SMS request sender:%s request: '%s' FAILED unknown translation",
	     octstr_get_cstr(msg->sms.receiver),
	     octstr_get_cstr(msg->sms.msgdata));
	goto error;
    }
    
    return 1;
    
error:
    return -1;
}


/*
 * send the 'reply', according to settings in 'trans' and 'msg'
 * return -1 if failed utterly, 0 otherwise
 */
static int send_message(URLTranslation *trans, Msg *msg)
{
    int max_msgs;
    Octstr *header, *footer, *suffix, *split_chars;
    int catenate;
    List *list;
    Msg *part;
    static char *empty = "<Empty reply from service provider>";
    
    gw_assert(msg != NULL);
    gw_assert(msg_type(msg) == sms);
    
    if (trans != NULL)
	max_msgs = urltrans_max_messages(trans);
    else
	max_msgs = 1;
    
    if (max_msgs == 0) {
	info(0, "No reply sent, denied.");
	msg_destroy(msg);
	return 0;
    }
    
    if (msg->sms.flag_udh == 0 && octstr_len(msg->sms.msgdata) == 0) {
	if (trans != NULL && urltrans_omit_empty(trans) != 0) {
	    max_msgs = 0;
	} else { 
	    octstr_replace(msg->sms.msgdata, empty, strlen(empty));
	}
    }

    if (max_msgs == 0)
    	return 0;

    if (trans == NULL) {
	header = NULL;
	footer = NULL;
	suffix = NULL;
	split_chars = NULL;
	catenate = 0;
    } else {
#define CREATE(cstr) ((cstr) ? octstr_create(cstr) : NULL)
    	header = CREATE(urltrans_header(trans));
	footer = CREATE(urltrans_footer(trans));
	suffix = CREATE(urltrans_split_suffix(trans));
	split_chars = CREATE(urltrans_split_chars(trans));
#undef CREATE
	catenate = urltrans_concatenation(trans);
    }

    if (catenate)
    	catenate = counter_increase(catenated_sms_counter) & 0xFF;

    list = sms_split(msg, header, footer, suffix, split_chars, catenate,
    	    	     max_msgs, sms_max_length);
    msg_destroy(msg);
    octstr_destroy(header);
    octstr_destroy(footer);
    octstr_destroy(suffix);
    octstr_destroy(split_chars);

    while ((part = list_extract_first(list)) != NULL)
	smsbox_send_to_bearerbox(part);
    list_destroy(list, NULL);
    
    return 0;
}

/* Function that test the authentification via Plugable authentification module*/
#ifdef HAVE_SECURITY_PAM_APPL_H /*Module for pam authentication */

typedef const struct pam_message pam_message_type;

static const char *PAM_username;
static const char *PAM_password;

static int PAM_conv (int num_msg, pam_message_type **msg,
	  struct pam_response **resp,
	  void *appdata_ptr)
{
  int             count = 0, replies = 0;
  struct pam_response *repl = NULL;
  int             size = sizeof(struct pam_response);

#define GET_MEM \
	if (!(repl = (gw_realloc(repl, size)))) \
  		return PAM_CONV_ERR; \
	size += sizeof(struct pam_response)
#define COPY_STRING(s) (s) ? gw_strdup(s) : NULL

  for (count = 0; count < num_msg; count++) {
    switch (msg[count]->msg_style) {
    case PAM_PROMPT_ECHO_ON:
      GET_MEM;
      repl[replies].resp_retcode = PAM_SUCCESS;
      repl[replies++].resp = COPY_STRING(PAM_username);
      /* PAM frees resp */
      break;
    case PAM_PROMPT_ECHO_OFF:
      GET_MEM;
      repl[replies].resp_retcode = PAM_SUCCESS;
      repl[replies++].resp = COPY_STRING(PAM_password);
      /* PAM frees resp */
      break;
    case PAM_TEXT_INFO:
      printf("unexpected message from PAM: %s\n",
	      msg[count]->msg);
      break;
    case PAM_ERROR_MSG:
    default:
      /* Must be an error of some sort... */
      printf("unexpected error from PAM: %s\n",
	     msg[count]->msg);
      gw_free(repl);
      return PAM_CONV_ERR;
    }
  }
  if (repl)
    *resp = repl;
  return PAM_SUCCESS;
}

static struct pam_conv PAM_conversation = {
  &PAM_conv,
  NULL
};


int authenticate(const char *login, const char *passwd)
{
  pam_handle_t	*pamh;
  int		pam_error;

  PAM_username = login;
  PAM_password = passwd;

  pam_error = pam_start("kannel", login, &PAM_conversation, &pamh);
  if (pam_error != PAM_SUCCESS
      || (pam_error = pam_authenticate(pamh, 0)) != PAM_SUCCESS) {
    pam_end(pamh, pam_error);
    return 0;
  }
  pam_end(pamh, PAM_SUCCESS);
  return 1;
}

/*
 * Check for matching username and password for requests.
 * Return an URLTranslation if successful NULL otherwise.
 */

int pam_authorise_user(List *list) {
  
  Octstr *val, *user = NULL;
  char *pwd, *login;
  int result;
  if ( (user=http_cgi_variable(list, "user"))==NULL  &&  (user=http_cgi_variable(list, "username") )==NULL )
    return 0;

  login =  octstr_get_cstr(user);
  
  if ( (val=http_cgi_variable(list, "password"))==NULL  &&  (val=http_cgi_variable(list, "pass"))==NULL )
    return 0;
  pwd   =  octstr_get_cstr(val);
  
  result=authenticate(login,pwd);
  
  return result;
}
#endif /* HAVE_SECURITY_PAM_APPL_H */

/*
 * Authentification whith the data base of kannel 
 * Check for matching username and password for requests.
 * Return an URLTranslation if successful NULL otherwise.
 */
static URLTranslation *default_authorise_user(List *list, char *client_ip) 
{
    URLTranslation *t = NULL;
    Octstr *val, *user = NULL;

    if ((user = http_cgi_variable(list, "username")) == NULL
        && (user = http_cgi_variable(list, "user")) == NULL)
        t = urltrans_find_username(translations, "default");
    else
        t = urltrans_find_username(translations, octstr_get_cstr(user));

    if (((val = http_cgi_variable(list, "password")) == NULL
         && (val = http_cgi_variable(list, "pass")) == NULL)
        || t == NULL ||
        strcmp(octstr_get_cstr(val), urltrans_password(t)) != 0)
    {
        /* if the password is not correct, reset the translation. */
        t = NULL;
    }
    if (t) {
        Octstr *ip = octstr_create(client_ip);

        if (is_allowed_ip(urltrans_allow_ip(t),
                  urltrans_allow_ip(t), ip) == 0)
        {
        warning(0, "Non-allowed connect tried by <%s> from <%s>, ignored",
            user ? octstr_get_cstr(user) : "default-user" ,
            client_ip);
        t = NULL;
        }
        octstr_destroy(ip);
    }
    return t;
}

static URLTranslation *authorise_user(List *list, char *client_ip) 
{
#ifdef HAVE_SECURITY_PAM_APPL_H
    URLTranslation *t = urltrans_find_username(translations, "pam");
    
    if (t != NULL) {
	if (pam_authorise_user(list))
	    return t;
	else 
	    return NULL;
    } else
	return default_authorise_user(list,client_ip);
#else
    return default_authorise_user(list,client_ip);
#endif
}

/*----------------------------------------------------------------*
 * PUBLIC FUNCTIONS
 */

void smsbox_req_init(URLTranslationList *transls,
		    Config *config,
		    int sms_max,
		    char *global,
		    char *accept_str)
{
    translations = transls;
    cfg = config;
    sms_max_length = sms_max;
    if (accept_str)
	sendsms_number_chars = accept_str;
    else
	sendsms_number_chars = SENDSMS_DEFAULT_CHARS;
    
    if (global != NULL)
	global_sender = gw_strdup(global);
    
    caller = http_caller_create();
    smsbox_requests = list_create();
    list_add_producer(smsbox_requests);
    receivers = dict_create(1024, destroy_receiver);
    catenated_sms_counter = counter_create();
    gwthread_create(smsbox_req_thread, NULL);
    gwthread_create(url_result_thread, NULL);
}

void smsbox_req_shutdown(void)
{
    list_remove_producer(smsbox_requests);
    gwthread_join_every(smsbox_req_thread);
    http_caller_signal_shutdown(caller);
    gwthread_join_every(url_result_thread);
    gw_assert(list_len(smsbox_requests) == 0);
    list_destroy(smsbox_requests, NULL);
    gw_free(global_sender);
    http_caller_destroy(caller);
    dict_destroy(receivers);
    counter_destroy(catenated_sms_counter);
}

long smsbox_req_count(void)
{
    return 0; /* XXX should check number of pending http requests */
}

void smsbox_req_thread(void *arg) 
{
    Msg *msg;
    Octstr *tmp, *reply;
    URLTranslation *trans;
    char *p;
    
    while ((msg = list_consume(smsbox_requests)) != NULL) {
	if (octstr_len(msg->sms.sender) == 0 ||
	    octstr_len(msg->sms.receiver) == 0) 
	{
	    error(0, "smsbox_req_thread: no sender/receiver, dump follows:");
	    msg_dump(msg, 0);
		    /* NACK should be returned here if we use such 
		       things... future implementation! */
	    continue;
	}
    
	if (octstr_compare(msg->sms.sender, msg->sms.receiver) == 0) {
	    info(0, "NOTE: sender and receiver same number <%s>, ignoring!",
		 octstr_get_cstr(msg->sms.sender));
	    continue;
	}
    
	trans = urltrans_find(translations, msg->sms.msgdata, 
	    	    	      msg->sms.smsc_id);
	if (trans == NULL) {
	    Octstr *t;
	    warning(0, "No translation found for <%s> from <%s> to <%s>",
		    octstr_get_cstr(msg->sms.msgdata),
		    octstr_get_cstr(msg->sms.sender),
		    octstr_get_cstr(msg->sms.receiver));
	    t = msg->sms.sender;
	    msg->sms.sender = msg->sms.receiver;
	    msg->sms.receiver = t;
	    goto error;
	}
    
	info(0, "Starting to service <%s> from <%s> to <%s>",
	     octstr_get_cstr(msg->sms.msgdata),
	     octstr_get_cstr(msg->sms.sender),
	     octstr_get_cstr(msg->sms.receiver));
    
	/*
	 * now, we change the sender (receiver now 'cause we swap them later)
	 * if faked-sender or similar set. Note that we ignore if the 
	 * replacement fails.
	 */
	tmp = octstr_duplicate(msg->sms.sender);
	    
	p = urltrans_faked_sender(trans);
	if (p != NULL)
	    octstr_replace(msg->sms.sender, p, strlen(p));
	else if (global_sender != NULL)
	    octstr_replace(msg->sms.sender, global_sender, 
	    	    	   strlen(global_sender));
	else {
	    octstr_replace(msg->sms.sender, 
	    	    	   octstr_get_cstr(msg->sms.receiver),
			   octstr_len(msg->sms.receiver));
	}
	octstr_destroy(msg->sms.receiver);
	msg->sms.receiver = tmp;
    
	/* TODO: check if the sender is approved to use this service */
    
	switch (obey_request(&reply, trans, msg)) {
	case -1:
    error:
	    error(0, "request failed");
	    /* XXX this can be something different, according to 
	       urltranslation */
	    reply = octstr_create("Request failed");
	    trans = NULL;	/* do not use any special translation */
    	    break;
	    
	case 1:
	    octstr_destroy(msg->sms.msgdata);
	    msg->sms.msgdata = reply;
	
	    msg->sms.flag_8bit = 0;
	    msg->sms.flag_udh  = 0;
	    msg->sms.time = time(NULL);	/* set current time */
	
	    if (send_message(trans, msg) < 0)
		error(0, "request_thread: failed");
    	    break;
    	
	default:
	    msg_destroy(msg);
	}
    }
}

/*****************************************************************************
 * Creates and sends an SMS message from an HTTP request
 * Args: list contains the CGI parameters
 */
char *smsbox_req_sendsms(List *list, char *client_ip)
{
    Msg *msg = NULL;
    URLTranslation *t = NULL;
    Octstr *from = NULL, *to;
    Octstr *text = NULL, *udh = NULL, *smsc = NULL;
    int ret;
    
    /* check the username and password */
    t = authorise_user(list, client_ip);
    if (t == NULL) {
	return "Authorization failed";
    }
    
    udh = http_cgi_variable(list, "udh");
    text = http_cgi_variable(list, "text");
    smsc = http_cgi_variable(list, "smsc");
    
    if ((to = http_cgi_variable(list, "to")) == NULL ||
	(text == NULL && udh == NULL)) {
	error(0, "/cgi-bin/sendsms got wrong args");
	return "Wrong sendsms args, rejected";
    }
    
    /*
     * check if UDH length is legal, or otherwise discard the
     * message, to prevent intentional buffer overflow schemes
     */
    if (udh != NULL) {
	if (octstr_len(udh) != (octstr_get_char(udh, 0) + 1))
	    return "UDH field misformed, rejected";
    }
    
    if (strspn(octstr_get_cstr(to), sendsms_number_chars) < octstr_len(to)) {
	info(0,"Illegal characters in 'to' string ('%s') vs '%s'",
	     octstr_get_cstr(to), sendsms_number_chars);
	return "Garbage 'to' field, rejected.";
    }
    
    if (urltrans_faked_sender(t) != NULL) {
	from = octstr_create(urltrans_faked_sender(t));
    } else if ((from = http_cgi_variable(list, "from")) != NULL &&
	       octstr_len(from) > 0) {
	from = octstr_duplicate(from);
    } else if (global_sender != NULL) {
	from = octstr_create(global_sender);
    } else {
	return "Sender missing and no global set, rejected";
    }
    
    info(0, "/cgi-bin/sendsms sender:<%s:%s> (%s) to:<%s> msg:<%s>",
	 urltrans_username(t), octstr_get_cstr(from), client_ip,
	 octstr_get_cstr(to),
	 udh == NULL ? octstr_get_cstr(text) : "<< UDH >>");
    
    /*
     * XXX here we should validate and split the 'to' field
     *   to allow multi-cast. Waiting for octstr_split...
     */
    msg = msg_create(sms);
    
    msg->sms.receiver = octstr_duplicate(to);
    msg->sms.sender = octstr_duplicate(from);
    msg->sms.msgdata = text ? octstr_duplicate(text) : octstr_create("");
    msg->sms.udhdata = udh ? octstr_duplicate(udh) : octstr_create("");
    
    /* new smsc-id argument - we should check this one, if able,
       but that's advanced logics -- Kalle */
    
    if (urltrans_forced_smsc(t)) {
	msg->sms.smsc_id = octstr_create(urltrans_forced_smsc(t));
	if (smsc)
	    info(0, "send-sms request smsc id ignored, "
	    	    "as smsc id forced to %s",
		    urltrans_forced_smsc(t));
    } else if (smsc) {
	msg->sms.smsc_id = octstr_duplicate(smsc);
    } else if (urltrans_default_smsc(t)) {
	msg->sms.smsc_id = octstr_create(urltrans_default_smsc(t));
    } else
	msg->sms.smsc_id = NULL;
    
    if (udh==NULL) {
	msg->sms.flag_8bit = 0;
	msg->sms.flag_udh  = 0;
    } else {
	msg->sms.flag_8bit = 1;
	msg->sms.flag_udh  = 1;
	octstr_dump(msg->sms.udhdata, 0);
    }
    
    msg->sms.time = time(NULL);
    
    ret = send_message(t, msg);
    
    if (ret == -1)
	goto error;
    
    alog("send-SMS request added - sender:%s:%s %s target:%s request: '%s'",
	 urltrans_username(t), octstr_get_cstr(from), client_ip,
	 octstr_get_cstr(to),
	 udh == NULL ? octstr_get_cstr(text) : "<< UDH >>");
	 octstr_destroy(from);
    
    return "Sent.";
    
error:
    error(0, "sendsms_request: failed");
    octstr_destroy(from);
    return "Sending failed.";
}


/*****************************************************************************
 * Creates and sends an SMS OTA (auto configuration) message from an HTTP request
 * Args: list contains the CGI parameters
 * 
 * This will be changed later to use an XML compiler.
 */
char *smsbox_req_sendota(List *list, char *client_ip)
{
    char *url = NULL, *desc = NULL, *ipaddr = NULL, *phonenum = NULL;
    char *username = NULL, *passwd = NULL, *id = NULL;
    char *speed;
    int bearer = -1, calltype = -1;
    int connection = CONN_CONT, security = 0, authent = AUTH_NORMAL;
    ConfigGroup *grp;
    char *p;
    Msg *msg = NULL;
    URLTranslation *t = NULL;
    int ret;
    Octstr *phonenumber = NULL, *otaid = NULL;
    
    /* check the username and password */
    t = authorise_user(list, client_ip);
    if (t == NULL) {
	return "Authorization failed";
    }
    
    phonenumber = http_cgi_variable(list, "phonenumber");
    if(phonenumber == NULL) {
	error(0, "/cgi-bin/sendota needs a valid phone number.");
	return "Wrong sendota args.";
    }
    
    /* check if a otaconfig id has been given and decide which OTA
     * properties to be send to the client otherwise send the default */
    otaid = http_cgi_variable(list, "otaid");
    if (otaid != NULL)
	id = octstr_get_cstr(otaid);
    
    grp = config_find_first_group(cfg, "group", "otaconfig");
    while (otaid != NULL && grp != NULL) {
	p = config_get(grp, "ota-id");
	if (p!= NULL && strcasecmp(p, id) == 0)
	    goto found;
	grp = config_find_next_group(grp, "group", "otaconfig");
    }
    
    if (otaid != NULL) {
	error(0, "/cgi-bin/sendota can't find otaconfig with ota-id '%s'.", 
	      id);
	return "Missing otaconfig group.";
    }
    
found:
    if ((p = config_get(grp, "location")) != NULL)
	url = p;
    if ((p = config_get(grp, "service")) != NULL)
	desc = p;
    if ((p = config_get(grp, "ipaddress")) != NULL)
	ipaddr = p;
    if ((p = config_get(grp, "phonenumber")) != NULL)
	phonenum = p;
    if ((p = config_get(grp, "bearer")) != NULL)
	bearer = (strcasecmp(p, "data") == 0)? BEARER_DATA : -1;
    if ((p = config_get(grp, "calltype")) != NULL)
	calltype = (strcasecmp(p, "isdn") == 0)? CALL_ISDN : -1;
    speed = SPEED_9660;
    if ((p = config_get(grp, "speed")) != NULL) {
	if (strcasecmp(p, "14400") == 0)
	    speed = SPEED_14400;
    }
    /* connection mode and security */
    if ((p = config_get(grp, "connection")) != NULL)
	connection = (strcasecmp(p, "temp") == 0)? CONN_TEMP : CONN_CONT;
    if ((p = config_get(grp, "pppsecurity")) != NULL)
	security = (strcasecmp(p, "on") == 0)? 1 : 0;
    if (security == 1)
	connection = (connection == CONN_CONT)? CONN_SECCONT : CONN_SECTEMP;
    
    if ((p = config_get(grp, "authentication")) != NULL)
	authent = (strcasecmp(p, "secure") == 0)? AUTH_SECURE : AUTH_NORMAL;
    
    if ((p = config_get(grp, "login")) != NULL)
	username = p;
    if ((p = config_get(grp, "secret")) != NULL)
	passwd = p;
    
    msg = msg_create(sms);
    if (msg == NULL)
    	goto error;
    
    msg->sms.udhdata = octstr_create("");
    
    octstr_append_from_hex(msg->sms.udhdata, "0504C34FC002");
    
    msg->sms.msgdata = octstr_create("");
    /* header for the data part of the message */
    octstr_append_from_hex(msg->sms.msgdata, "010604039481EA0001");
    /* unknow field */
    octstr_append_from_hex(msg->sms.msgdata, "45C60601");
    /* bearer type */
    if (bearer != -1) {
	octstr_append_from_hex(msg->sms.msgdata, "8712");
	octstr_append_char(msg->sms.msgdata, bearer);
	octstr_append_from_hex(msg->sms.msgdata, ENDTAG);
    }
    /* IP address */
    if (ipaddr != NULL) {
	octstr_append_from_hex(msg->sms.msgdata , "87131103");
	octstr_append_cstr(msg->sms.msgdata, ipaddr);
	octstr_append_from_hex(msg->sms.msgdata, "0001");
    }
    /* connection type */
    if (connection != -1) {
	octstr_append_from_hex(msg->sms.msgdata, "8714");
	octstr_append_char(msg->sms.msgdata, connection);
	octstr_append_from_hex(msg->sms.msgdata, ENDTAG);
    }
    /* phone number */
    if (phonenum != NULL) {
	octstr_append_from_hex(msg->sms.msgdata, "87211103");
	octstr_append_cstr(msg->sms.msgdata, phonenum);
	octstr_append_from_hex(msg->sms.msgdata, "0001");
    }
    /* authentication */
    octstr_append_from_hex(msg->sms.msgdata, "8722");
    octstr_append_char(msg->sms.msgdata, authent);
    octstr_append_from_hex(msg->sms.msgdata, ENDTAG);
    /* user name */
    if (username != NULL) {
	octstr_append_from_hex(msg->sms.msgdata, "87231103");
	octstr_append_cstr(msg->sms.msgdata, username);
	octstr_append_from_hex(msg->sms.msgdata, "0001");
    }
    /* password */
    if (passwd != NULL) {
	octstr_append_from_hex(msg->sms.msgdata, "87241103");
	octstr_append_cstr(msg->sms.msgdata, passwd);
	octstr_append_from_hex(msg->sms.msgdata, "0001");
    }
    /* data call type */
    if (calltype != -1) {
	octstr_append_from_hex(msg->sms.msgdata, "8728");
	octstr_append_char(msg->sms.msgdata, calltype);
	octstr_append_from_hex(msg->sms.msgdata, ENDTAG);
    }
    /* speed */
    octstr_append_from_hex(msg->sms.msgdata, "8729");
    octstr_append_from_hex(msg->sms.msgdata, speed);
    octstr_append_from_hex(msg->sms.msgdata, ENDTAG);
    octstr_append_from_hex(msg->sms.msgdata, ENDTAG);
    /* homepage */
    if (url != NULL) {
	octstr_append_from_hex(msg->sms.msgdata, "86071103");
	octstr_append_cstr(msg->sms.msgdata, url);
	octstr_append_from_hex(msg->sms.msgdata, "0001");
    }
    /* unknow field */
    octstr_append_from_hex(msg->sms.msgdata, "C60801");
    /* service description */
    if (desc != NULL) {
	octstr_append_from_hex(msg->sms.msgdata, "87151103");
	octstr_append_cstr(msg->sms.msgdata, desc);
	octstr_append_from_hex(msg->sms.msgdata, "0001");
    }
    /* message footer */
    octstr_append_from_hex(msg->sms.msgdata, "0101");
    
    msg->sms.receiver = octstr_duplicate(phonenumber);
    /* msg->sms.sender = from; */	
    msg->sms.flag_8bit = 1;
    msg->sms.flag_udh  = 1;
    
    msg->sms.time = time(NULL);
    
    octstr_dump(msg->sms.msgdata, 0);
    
    info(0, "/cgi-bin/sendota <%s> <%s>", id, octstr_get_cstr(phonenumber));
    
    /* send_message frees the 'msg' */
    ret = send_message(t, msg); 
    
    if (ret == -1)
	goto error;
    
    return "Sent.";
    
error:
    error(0, "sendota_request: failed");
    /*octstr_destroy(from);*/
    return "Sending failed.";
}

